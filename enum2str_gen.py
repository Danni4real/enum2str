# tool used to gen enum2str source code
# needed : pyparsing version >= 3.1.0

import os
import io
import re
import pyparsing as pp

SRC_DIR = '.'
EXCLUDE_DIRS = {'f', 'g'}
EXCLUDE_FILES = {'c.h', 'd.h'}
OUTPUT_CPP_FILE = 'enum2str.cpp'
OUTPUT_HEAD_FILE = 'enum2str.h'


def scan_dir(base_dir):
    for root, dirs, files in os.walk(base_dir, topdown=True):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for file in files:
            if file.endswith('.h') and file not in EXCLUDE_FILES:
                yield os.path.join(root, file)  # relative path of file


def rm_comments(text):
    def replacer(match):
        s = match.group(0)
        if s.startswith('/'):
            return " "  # note: a space and not an empty string
        else:
            return s

    pattern = re.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE
    )
    return re.sub(pattern, replacer, text)


# main starts
if os.path.exists(OUTPUT_CPP_FILE):
    os.remove(OUTPUT_CPP_FILE)
if os.path.exists(OUTPUT_HEAD_FILE):
    os.remove(OUTPUT_HEAD_FILE)

output_cpp_file = open(OUTPUT_CPP_FILE, 'a')
output_head_file = open(OUTPUT_HEAD_FILE, 'a')

output_head_file.write("// auto generated by enum2str_gen.py, modify it if needed\n"
                       "#ifndef ENUM_2_STR_H__\n"
                       "#define ENUM_2_STR_H__\n"
                       "#define ENUM2STR(...) enum2str(__VA_ARGS__).data()\n\n"
                       "#include <string>\n")

output_cpp_file.write("// auto generated by enum2str_gen.py, modify it if needed\n"
                      "#include <string>\n")

# syntax we don't want to see in the final parse tree
LBRACE, RBRACE, EQ, COMMA, COLON = pp.Suppress.using_each("{}=,:")
KEYWORD_ENUM = 'enum'
KEYWORD_CLASS = 'class'
KEYWORD_INT = 'int'
KEYWORD_CHAR = 'char'

integer = pp.Word(pp.nums + "-")
identifier = pp.Word(pp.alphas + "_", pp.alphanums + "_")

enum_key_word = pp.Suppress(KEYWORD_ENUM) + pp.Optional(KEYWORD_CLASS)
enum_type = pp.Optional(COLON) + pp.Optional(KEYWORD_INT) + pp.Optional(KEYWORD_CHAR)  # add possible keywords
enum_value = pp.Group(identifier("value") + pp.Optional(EQ + integer()))
enum_values = pp.Group(enum_value + (COMMA + enum_value)[...] + pp.Optional(COMMA))
enum_block = (enum_key_word + identifier("name") + enum_type +
              LBRACE + enum_values("value_list") + RBRACE)

# find instances of enums ignoring other syntax
for input_file_path in scan_dir(SRC_DIR):
    input_file = open(input_file_path, 'r')
    cpp_cache = io.StringIO()
    head_cache = io.StringIO()

    for enum, start, stop in enum_block.scan_string(rm_comments(input_file.read())):
        head_cache.write("std::string enum2str(%s e);\n" % enum.name)
        cpp_cache.write("std::string enum2str(%s e) {\n" % enum.name)
        cpp_cache.write("  switch ((int)e) {\n")
        for item in enum.value_list:
            cpp_cache.write("    case %s: return \"%s\";\n" % (item.value, item.value))
        cpp_cache.write("    default: return std::to_string(e);\n  }\n}\n")

    if len(cpp_cache.getvalue()) != 0:
        output_cpp_file.write("#include \"%s\"\n" % input_file_path)
        output_head_file.write("#include \"%s\"\n" % input_file_path)
        output_cpp_file.write(cpp_cache.getvalue())
        output_head_file.write(head_cache.getvalue())

output_head_file.write("#endif  // ENUM_2_STR_H__\n")
